var A=Object.defineProperty;var r=(e,t)=>A(e,"name",{value:t,configurable:!0});var h=r((e,t="ms")=>new Date(Date.now()+(t==="sec"?e*1e3:e)),"getDate");import{createHash as L}from"@better-auth/utils/hash";import{base64Url as T}from"@better-auth/utils/base64";async function U(e){let t=await L("SHA-256").digest(e);return T.encode(new Uint8Array(t),{padding:!1})}r(U,"generateCodeChallenge");function x(e){return{tokenType:e.token_type,accessToken:e.access_token,refreshToken:e.refresh_token,accessTokenExpiresAt:e.expires_in?h(e.expires_in,"sec"):void 0,scopes:e?.scope?typeof e.scope=="string"?e.scope.split(" "):e.scope:[],idToken:e.id_token}}r(x,"getOAuth2Tokens");async function $({id:e,options:t,authorizationEndpoint:n,state:o,codeVerifier:c,scopes:d,claims:s,redirectURI:p,duration:l}){let i=new URL(n);if(i.searchParams.set("response_type","code"),i.searchParams.set("client_id",t.clientId),i.searchParams.set("state",o),i.searchParams.set("scope",d.join(" ")),i.searchParams.set("redirect_uri",t.redirectURI||p),c){let f=await U(c);i.searchParams.set("code_challenge_method","S256"),i.searchParams.set("code_challenge",f)}if(s){let f=s.reduce((m,k)=>(m[k]=null,m),{});i.searchParams.set("claims",JSON.stringify({id_token:{email:null,email_verified:null,...f}}))}return l&&i.searchParams.set("duration",l),i}r($,"createAuthorizationURL");import{betterFetch as w}from"@better-fetch/fetch";import{jwtVerify as v}from"jose";async function M({code:e,codeVerifier:t,redirectURI:n,options:o,tokenEndpoint:c,authentication:d}){let s=new URLSearchParams,p={"content-type":"application/x-www-form-urlencoded",accept:"application/json","user-agent":"better-auth"};if(s.set("grant_type","authorization_code"),s.set("code",e),t&&s.set("code_verifier",t),s.set("redirect_uri",n),d==="basic"){let m=btoa(`${o.clientId}:${o.clientSecret}`);p.authorization=`Basic ${m}`}else s.set("client_id",o.clientId),s.set("client_secret",o.clientSecret);let{data:l,error:i}=await w(c,{method:"POST",body:s,headers:p});if(i)throw i;return x(l)}r(M,"validateAuthorizationCode");async function X(e,t){let{data:n,error:o}=await w(t,{method:"GET",headers:{accept:"application/json","user-agent":"better-auth"}});if(o)throw o;let c=n.keys,d=JSON.parse(atob(e.split(".")[0])),s=c.find(l=>l.kid===d.kid);if(!s)throw new Error("Key not found");return await v(e,s)}r(X,"validateToken");import{z as a}from"zod";import{APIError as b}from"better-call";var g=Object.create(null),u=r(e=>globalThis.process?.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?g:globalThis),"_getEnv"),_=new Proxy(g,{get(e,t){return u()[t]??g[t]},has(e,t){let n=u();return t in n||t in g},set(e,t,n){let o=u(!0);return o[t]=n,!0},deleteProperty(e,t){if(!t)return!1;let n=u(!0);return delete n[t],!0},ownKeys(){let e=u(!0);return Object.keys(e)}});function E(e){return e?e!=="false":!1}r(E,"toBoolean");var P=typeof process<"u"&&process.env&&process.env.NODE_ENV||"";var W=P==="test"||E(_.TEST);function R(e){try{return new URL(e).origin}catch{return null}}r(R,"getOrigin");import{createHash as Re}from"@better-auth/utils/hash";import{xchacha20poly1305 as ke}from"@noble/ciphers/chacha";import{bytesToHex as Le,hexToBytes as Te,utf8ToBytes as ve}from"@noble/ciphers/utils";import{managedNonce as Pe}from"@noble/ciphers/webcrypto";import{scryptAsync as ue}from"@noble/hashes/scrypt";import{getRandomValues as me}from"uncrypto";import{hex as ye}from"@better-auth/utils/hex";import{createRandomStringGenerator as S}from"@better-auth/utils/random";var y=S("a-z","0-9","A-Z","-_");async function $e(e,t){let n=e.body?.callbackURL||(e.query?.currentURL?R(e.query?.currentURL):"")||e.context.options.baseURL;if(!n)throw new b("BAD_REQUEST",{message:"callbackURL is required"});let o=y(128),c=y(32),d=JSON.stringify({callbackURL:n,codeVerifier:o,errorURL:e.body?.errorCallbackURL||e.query?.currentURL,newUserURL:e.body?.newUserCallbackURL,link:t,expiresAt:Date.now()+10*60*1e3}),s=new Date;s.setMinutes(s.getMinutes()+10);let p=await e.context.internalAdapter.createVerificationValue({value:d,identifier:c,expiresAt:s});if(!p)throw e.context.logger.error("Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database"),new b("INTERNAL_SERVER_ERROR",{message:"Unable to create verification"});return{state:p.identifier,codeVerifier:o}}r($e,"generateState");async function qe(e){let t=e.query.state||e.body.state,n=await e.context.internalAdapter.findVerificationValue(t);if(!n)throw e.context.logger.error("State Mismatch. Verification not found",{state:t}),e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);let o=a.object({callbackURL:a.string(),codeVerifier:a.string(),errorURL:a.string().optional(),newUserURL:a.string().optional(),expiresAt:a.number(),link:a.object({email:a.string(),userId:a.string()}).optional()}).parse(JSON.parse(n.value));if(o.errorURL||(o.errorURL=`${e.context.baseURL}/error`),o.expiresAt<Date.now())throw await e.context.internalAdapter.deleteVerificationValue(n.id),e.context.logger.error("State expired.",{state:t}),e.redirect(`${e.context.baseURL}/error?error=please_restart_the_process`);return await e.context.internalAdapter.deleteVerificationValue(n.id),o}r(qe,"parseState");export{$ as createAuthorizationURL,U as generateCodeChallenge,$e as generateState,x as getOAuth2Tokens,qe as parseState,M as validateAuthorizationCode,X as validateToken};
