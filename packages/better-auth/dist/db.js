var te=Object.defineProperty;var n=(e,s)=>te(e,"name",{value:s,configurable:!0});var L=n((e,s="ms")=>new Date(Date.now()+(s==="sec"?e*1e3:e)),"getDate");import{z as w}from"zod";import{APIError as ke}from"better-call";var Re=w.object({id:w.string(),providerId:w.string(),accountId:w.string(),userId:w.string(),accessToken:w.string().nullish(),refreshToken:w.string().nullish(),idToken:w.string().nullish(),accessTokenExpiresAt:w.date().nullish(),refreshTokenExpiresAt:w.date().nullish(),scope:w.string().nullish(),password:w.string().nullish(),createdAt:w.date().default(()=>new Date),updatedAt:w.date().default(()=>new Date)}),Fe=w.object({id:w.string(),email:w.string().transform(e=>e.toLowerCase()),emailVerified:w.boolean().default(!1),name:w.string(),image:w.string().nullish(),createdAt:w.date().default(()=>new Date),updatedAt:w.date().default(()=>new Date)}),Oe=w.object({id:w.string(),userId:w.string(),expiresAt:w.date(),createdAt:w.date().default(()=>new Date),updatedAt:w.date().default(()=>new Date),token:w.string(),ipAddress:w.string().nullish(),userAgent:w.string().nullish()}),De=w.object({id:w.string(),value:w.string(),createdAt:w.date().default(()=>new Date),updatedAt:w.date().default(()=>new Date),expiresAt:w.date(),identifier:w.string()});function M(e,s){let f=s.fields,l={};for(let p in e){let h=f[p];if(!h){l[p]=e[p];continue}h.returned!==!1&&(l[p]=e[p])}return l}n(M,"parseOutputData");function _(e,s){let f={...s==="user"?e.user?.additionalFields:{},...s==="session"?e.session?.additionalFields:{}};for(let l of e.plugins||[])l.schema&&l.schema[s]&&(f={...f,...l.schema[s].fields});return f}n(_,"getAllFields");function B(e,s){let f=_(e,"user");return M(s,{fields:f})}n(B,"parseUserOutput");function I(e,s){let f=_(e,"session");return M(s,{fields:f})}n(I,"parseSessionOutput");function C(e,s){let f=s.hooks;async function l(u,g,m){let t=u;for(let d of f||[]){let o=d[g]?.create?.before;if(o){let i=await o(u);if(i===!1)return null;typeof i=="object"&&"data"in i&&(t=i.data)}}let r=m?await m.fn(t):null,a=!m||m.executeMainFn?await e.create({model:g,data:t}):r;for(let d of f||[]){let o=d[g]?.create?.after;o&&await o(a)}return a}n(l,"createWithHooks");async function p(u,g,m,t){let r=u;for(let o of f||[]){let i=o[m]?.update?.before;if(i){let c=await i(u);if(c===!1)return null;r=typeof c=="object"?c.data:c}}let a=t?await t.fn(r):null,d=!t||t.executeMainFn?await e.update({model:m,update:r,where:g}):a;for(let o of f||[]){let i=o[m]?.update?.after;i&&await i(d)}return d}n(p,"updateWithHooks");async function h(u,g,m,t){let r=u;for(let o of f||[]){let i=o[m]?.update?.before;if(i){let c=await i(u);if(c===!1)return null;r=typeof c=="object"?c.data:c}}let a=t?await t.fn(r):null,d=!t||t.executeMainFn?await e.updateMany({model:m,update:r,where:g}):a;for(let o of f||[]){let i=o[m]?.update?.after;i&&await i(d)}return d}return n(h,"updateManyWithHooks"),{createWithHooks:l,updateWithHooks:p,updateManyWithHooks:h}}n(C,"getWithHooks");var N=Object.create(null),O=n(e=>globalThis.process?.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?N:globalThis),"_getEnv"),j=new Proxy(N,{get(e,s){return O()[s]??N[s]},has(e,s){let f=O();return s in f||s in N},set(e,s,f){let l=O(!0);return l[s]=f,!0},deleteProperty(e,s){if(!s)return!1;let f=O(!0);return delete f[s],!0},ownKeys(){let e=O(!0);return Object.keys(e)}});function re(e){return e?e!=="false":!1}n(re,"toBoolean");var ne=typeof process<"u"&&process.env&&process.env.NODE_ENV||"";var $=ne==="test"||re(j.TEST);function K(e,s){if(s.advanced?.ipAddress?.disableIpTracking)return null;let f="127.0.0.1";if($)return f;let p=s.advanced?.ipAddress?.ipAddressHeaders||["x-client-ip","x-forwarded-for","cf-connecting-ip","fastly-client-ip","x-real-ip","x-cluster-client-ip","x-forwarded","forwarded-for","forwarded"],h=e instanceof Request?e.headers:e;for(let u of p){let g=h.get(u);if(typeof g=="string"){let m=g.split(",")[0].trim();if(m)return m}}return null}n(K,"getIp");function U(e){try{return JSON.parse(e)}catch{return null}}n(U,"safeJSONParse");import{createRandomStringGenerator as ie}from"@better-auth/utils/random";var R=n(e=>ie("a-z","A-Z","0-9")(e||32),"generateId");import{z as St}from"zod";import{APIError as Lt}from"better-call";var D=class extends Error{static{n(this,"BetterAuthError")}constructor(s,f){super(s),this.name="BetterAuthError",this.message=s,this.cause=f,this.stack=""}};import{createHash as yt}from"@better-auth/utils/hash";import{xchacha20poly1305 as At}from"@noble/ciphers/chacha";import{bytesToHex as xt,hexToBytes as wt,utf8ToBytes as bt}from"@noble/ciphers/utils";import{managedNonce as Tt}from"@noble/ciphers/webcrypto";import{scryptAsync as st}from"@noble/hashes/scrypt";import{getRandomValues as ot}from"uncrypto";import{hex as ut}from"@better-auth/utils/hex";import{createRandomStringGenerator as se}from"@better-auth/utils/random";var ae=se("a-z","0-9","A-Z","-_");var E=["info","success","warn","error","debug"];function oe(e,s){return E.indexOf(s)<=E.indexOf(e)}n(oe,"shouldPublishLog");var v={reset:"\x1B[0m",bright:"\x1B[1m",dim:"\x1B[2m",underscore:"\x1B[4m",blink:"\x1B[5m",reverse:"\x1B[7m",hidden:"\x1B[8m",fg:{black:"\x1B[30m",red:"\x1B[31m",green:"\x1B[32m",yellow:"\x1B[33m",blue:"\x1B[34m",magenta:"\x1B[35m",cyan:"\x1B[36m",white:"\x1B[37m"},bg:{black:"\x1B[40m",red:"\x1B[41m",green:"\x1B[42m",yellow:"\x1B[43m",blue:"\x1B[44m",magenta:"\x1B[45m",cyan:"\x1B[46m",white:"\x1B[47m"}},de={info:v.fg.blue,success:v.fg.green,warn:v.fg.yellow,error:v.fg.red,debug:v.fg.magenta},ue=n((e,s)=>{let f=new Date().toISOString();return`${v.dim}${f}${v.reset} ${de[e]}${e.toUpperCase()}${v.reset} ${v.bright}Better Auth${v.reset} ${s}`},"formatMessage"),V=n(e=>{let s=e?.disabled!==!0,f=e?.level??"error",l=n((p,h,u=[])=>{if(!s||!oe(f,p))return;let g=ue(p,h);if(!e||typeof e.log!="function"){p==="error"?console.error(g,...u):p==="warn"?console.warn(g,...u):console.log(g,...u);return}e.log(p==="success"?"info":p,g,...u)},"LogFunc");return Object.fromEntries(E.map(p=>[p,(...[h,...u])=>l(p,h,u)]))},"createLogger"),H=V();var tr=n((e,s)=>{let f=s.options,l=f.secondaryStorage,p=f.session?.expiresIn||60*60*24*7,{createWithHooks:h,updateWithHooks:u,updateManyWithHooks:g}=C(e,s),m=n(async t=>{await l?.set(t.token,JSON.stringify({session:t.session,user:t.user}),t.session.expiresAt?Math.floor(((t.session.expiresAt instanceof Date?t.session.expiresAt.getTime():new Date(t.session.expiresAt).getTime())-Date.now())/1e3):p)},"setSecondaryStorage");return{createOAuthUser:n(async(t,r)=>{let a=await h({createdAt:new Date,updatedAt:new Date,...t},"user"),d=await h({...r,userId:a.id||t.id,createdAt:new Date,updatedAt:new Date},"account");return{user:a,account:d}},"createOAuthUser"),createUser:n(async t=>await h({createdAt:new Date,updatedAt:new Date,emailVerified:!1,...t,email:t.email.toLowerCase()},"user"),"createUser"),createAccount:n(async t=>await h({createdAt:new Date,updatedAt:new Date,...t},"account"),"createAccount"),listSessions:n(async t=>{if(l){let a=await l.get(`active-sessions-${t}`);if(!a)return[];let d=U(a)||[],o=Date.now(),i=d.filter(A=>A.expiresAt>o),c=[];for(let A of i){let y=await l.get(A.token);if(y){let b=JSON.parse(y),x=I(s.options,{...b.session,expiresAt:new Date(b.session.expiresAt)});c.push(x)}}return c}return await e.findMany({model:"session",where:[{field:"userId",value:t}]})},"listSessions"),listUsers:n(async(t,r,a,d)=>await e.findMany({model:"user",limit:t,offset:r,sortBy:a,where:d}),"listUsers"),deleteUser:n(async t=>{await e.deleteMany({model:"session",where:[{field:"userId",value:t}]}),await e.deleteMany({model:"account",where:[{field:"userId",value:t}]}),await e.delete({model:"user",where:[{field:"id",value:t}]})},"deleteUser"),createSession:n(async(t,r,a,d)=>{let o=r instanceof Request?r.headers:r,{id:i,...c}=d||{},A={ipAddress:r&&K(r,s.options)||"",userAgent:o?.get("user-agent")||"",...c,expiresAt:a?L(60*60*24,"sec"):L(p,"sec"),userId:t,token:R(32),createdAt:new Date,updatedAt:new Date};return await h(A,"session",l?{fn:n(async()=>{let b=await e.findOne({model:"user",where:[{field:"id",value:t}]});l.set(A.token,JSON.stringify({session:A,user:b}),p);let x=await l.get(`active-sessions-${t}`),T=[],P=Date.now();return x&&(T=U(x)||[],T=T.filter(ee=>ee.expiresAt>P)),T.push({token:A.token,expiresAt:P+p*1e3}),await l.set(`active-sessions-${t}`,JSON.stringify(T),p),A},"fn"),executeMainFn:f.session?.storeSessionInDatabase}:void 0)},"createSession"),findSession:n(async t=>{if(l){let i=await l.get(t);if(i){let c=JSON.parse(i),A=I(s.options,{...c.session,expiresAt:new Date(c.session.expiresAt),createdAt:new Date(c.session.createdAt),updatedAt:new Date(c.session.updatedAt)}),y=B(s.options,{...c.user,createdAt:new Date(c.user.createdAt),updatedAt:new Date(c.user.updatedAt)});return{session:A,user:y}}}let r=await e.findOne({model:"session",where:[{value:t,field:"token"}]});if(!r)return null;let a=await e.findOne({model:"user",where:[{value:r.userId,field:"id"}]});if(!a)return null;let d=I(s.options,r),o=B(s.options,a);return l&&await m({token:t,user:o,session:d}),{session:d,user:o}},"findSession"),findSessions:n(async t=>{if(l){let o=[];for(let i of t){let c=await l.get(i);if(c){let A=JSON.parse(c),y={session:{...A.session,expiresAt:new Date(A.session.expiresAt)},user:{...A.user,createdAt:new Date(A.user.createdAt),updatedAt:new Date(A.user.updatedAt)}};o.push(y)}}return o}let r=await e.findMany({model:"session",where:[{field:"token",value:t,operator:"in"}]}),a=r.map(o=>o.userId);if(!a.length)return[];let d=await e.findMany({model:"user",where:[{field:"id",value:a,operator:"in"}]});return r.map(o=>{let i=d.find(c=>c.id===o.userId);return i?{session:o,user:i}:null})},"findSessions"),updateSession:n(async(t,r)=>await u(r,[{field:"token",value:t}],"session",l?{async fn(d){let o=await l.get(t),i=null;if(o){let c=JSON.parse(o);return i={...c.session,...d},await m({token:t,user:c.user,session:i}),i}else return null},executeMainFn:f.session?.storeSessionInDatabase}:void 0),"updateSession"),deleteSession:n(async t=>{if(l){await l.delete(t),f.session?.storeSessionInDatabase&&await e.delete({model:"session",where:[{field:"token",value:t}]});return}await e.delete({model:"session",where:[{field:"token",value:t}]})},"deleteSession"),deleteAccounts:n(async t=>{await e.deleteMany({model:"account",where:[{field:"userId",value:t}]})},"deleteAccounts"),deleteSessions:n(async t=>{if(l){if(typeof t=="string"){let r=await l.get(`active-sessions-${t}`),a=r?U(r):[];if(!a)return;for(let d of a)await l.delete(d.token)}else for(let r of t)await l.get(r)&&await l.delete(r);f.session?.storeSessionInDatabase&&await e.deleteMany({model:"session",where:[{field:Array.isArray(t)?"token":"userId",value:t,operator:Array.isArray(t)?"in":void 0}]});return}await e.deleteMany({model:"session",where:[{field:Array.isArray(t)?"token":"userId",value:t,operator:Array.isArray(t)?"in":void 0}]})},"deleteSessions"),findOAuthUser:n(async(t,r,a)=>{let d=null;if(d=await e.findOne({model:"user",where:[{value:t.toLowerCase(),field:"email"}]}),!d){let i=await e.findOne({model:"account",where:[{value:r,field:"accountId"},{value:a,field:"providerId"}]});return i?(d=await e.findOne({model:"user",where:[{value:i.userId,field:"id"}]}),{user:d,accounts:[i]}):null}let o=await e.findMany({model:"account",where:[{value:d.id,field:"userId"}]});return{user:d,accounts:o||[]}},"findOAuthUser"),findUserByEmail:n(async(t,r)=>{let a=await e.findOne({model:"user",where:[{value:t.toLowerCase(),field:"email"}]});if(!a)return null;if(r?.includeAccounts){let d=await e.findMany({model:"account",where:[{value:a.id,field:"userId"}]});return{user:a,accounts:d}}return{user:a,accounts:[]}},"findUserByEmail"),findUserById:n(async t=>await e.findOne({model:"user",where:[{field:"id",value:t}]}),"findUserById"),linkAccount:n(async t=>await h({...t,createdAt:new Date,updatedAt:new Date},"account"),"linkAccount"),updateUser:n(async(t,r)=>await u(r,[{field:"id",value:t}],"user"),"updateUser"),updateUserByEmail:n(async(t,r)=>await u(r,[{field:"email",value:t}],"user"),"updateUserByEmail"),updatePassword:n(async(t,r)=>{await g({password:r},[{field:"userId",value:t},{field:"providerId",value:"credential"}],"account")},"updatePassword"),findAccounts:n(async t=>await e.findMany({model:"account",where:[{field:"userId",value:t}]}),"findAccounts"),findAccount:n(async t=>await e.findOne({model:"account",where:[{field:"accountId",value:t}]}),"findAccount"),findAccountByUserId:n(async t=>await e.findMany({model:"account",where:[{field:"userId",value:t}]}),"findAccountByUserId"),updateAccount:n(async(t,r)=>await u(r,[{field:"id",value:t}],"account"),"updateAccount"),createVerificationValue:n(async t=>await h({createdAt:new Date,updatedAt:new Date,...t},"verification"),"createVerificationValue"),findVerificationValue:n(async t=>(await e.findMany({model:"verification",where:[{field:"identifier",value:t}],sortBy:{field:"createdAt",direction:"desc"},limit:1}))[0],"findVerificationValue"),deleteVerificationValue:n(async t=>{await e.delete({model:"verification",where:[{field:"id",value:t}]})},"deleteVerificationValue"),deleteVerificationByIdentifier:n(async t=>{await e.delete({model:"verification",where:[{field:"identifier",value:t}]})},"deleteVerificationByIdentifier"),updateVerificationValue:n(async(t,r)=>await u(r,[{field:"id",value:t}],"verification"),"updateVerificationValue")}},"createInternalAdapter");var ir=n((e,s)=>({type:e,...s}),"createFieldAttribute");var k=n(e=>{let s=e.plugins?.reduce((m,t)=>{let r=t.schema;if(!r)return m;for(let[a,d]of Object.entries(r))m[a]={fields:{...m[a]?.fields,...d.fields},modelName:d.modelName||a};return m},{}),f=e.rateLimit?.storage==="database",l={rateLimit:{modelName:e.rateLimit?.modelName||"rateLimit",fields:{key:{type:"string",fieldName:e.rateLimit?.fields?.key||"key"},count:{type:"number",fieldName:e.rateLimit?.fields?.count||"count"},lastRequest:{type:"number",fieldName:e.rateLimit?.fields?.lastRequest||"lastRequest"}}}},{user:p,session:h,account:u,...g}=s||{};return{user:{modelName:e.user?.modelName||"user",fields:{name:{type:"string",required:!0,fieldName:e.user?.fields?.name||"name"},email:{type:"string",unique:!0,required:!0,fieldName:e.user?.fields?.email||"email"},emailVerified:{type:"boolean",defaultValue:n(()=>!1,"defaultValue"),required:!0,fieldName:e.user?.fields?.emailVerified||"emailVerified"},image:{type:"string",required:!1,fieldName:e.user?.fields?.image||"image"},createdAt:{type:"date",defaultValue:n(()=>new Date,"defaultValue"),required:!0,fieldName:e.user?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",defaultValue:n(()=>new Date,"defaultValue"),required:!0,fieldName:e.user?.fields?.updatedAt||"updatedAt"},...p?.fields,...e.user?.additionalFields},order:1},session:{modelName:e.session?.modelName||"session",fields:{expiresAt:{type:"date",required:!0,fieldName:e.session?.fields?.expiresAt||"expiresAt"},token:{type:"string",required:!0,fieldName:e.session?.fields?.token||"token",unique:!0},createdAt:{type:"date",required:!0,fieldName:e.session?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!0,fieldName:e.session?.fields?.updatedAt||"updatedAt"},ipAddress:{type:"string",required:!1,fieldName:e.session?.fields?.ipAddress||"ipAddress"},userAgent:{type:"string",required:!1,fieldName:e.session?.fields?.userAgent||"userAgent"},userId:{type:"string",fieldName:e.session?.fields?.userId||"userId",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0},...h?.fields,...e.session?.additionalFields},order:2},account:{modelName:e.account?.modelName||"account",fields:{accountId:{type:"string",required:!0,fieldName:e.account?.fields?.accountId||"accountId"},providerId:{type:"string",required:!0,fieldName:e.account?.fields?.providerId||"providerId"},userId:{type:"string",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0,fieldName:e.account?.fields?.userId||"userId"},accessToken:{type:"string",required:!1,fieldName:e.account?.fields?.accessToken||"accessToken"},refreshToken:{type:"string",required:!1,fieldName:e.account?.fields?.refreshToken||"refreshToken"},idToken:{type:"string",required:!1,fieldName:e.account?.fields?.idToken||"idToken"},accessTokenExpiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.accessTokenExpiresAt||"accessTokenExpiresAt"},refreshTokenExpiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.accessTokenExpiresAt||"refreshTokenExpiresAt"},scope:{type:"string",required:!1,fieldName:e.account?.fields?.scope||"scope"},password:{type:"string",required:!1,fieldName:e.account?.fields?.password||"password"},createdAt:{type:"date",required:!0,fieldName:e.account?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!0,fieldName:e.account?.fields?.updatedAt||"updatedAt"},...u?.fields},order:3},verification:{modelName:e.verification?.modelName||"verification",fields:{identifier:{type:"string",required:!0,fieldName:e.verification?.fields?.identifier||"identifier"},value:{type:"string",required:!0,fieldName:e.verification?.fields?.value||"value"},expiresAt:{type:"date",required:!0,fieldName:e.verification?.fields?.expiresAt||"expiresAt"},createdAt:{type:"date",required:!1,defaultValue:n(()=>new Date,"defaultValue"),fieldName:e.verification?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!1,defaultValue:n(()=>new Date,"defaultValue"),fieldName:e.verification?.fields?.updatedAt||"updatedAt"}},order:4},...g,...f?l:{}}},"getAuthTables");import{z as F}from"zod";function lr(e){return F.object({...Object.keys(e).reduce((f,l)=>{let p=e[l];if(!p)return f;if(p.type==="string[]"||p.type==="number[]")return{...f,[l]:F.array(p.type==="string[]"?F.string():F.number())};if(Array.isArray(p.type))return{...f,[l]:F.any()};let h=F[p.type]();return p?.required===!1&&(h=h.optional()),p?.returned===!1?f:{...f,[l]:h}},{})})}n(lr,"toZodSchema");import{Kysely as W,MssqlDialect as le}from"kysely";import{MysqlDialect as J,PostgresDialect as z,SqliteDialect as G}from"kysely";function Z(e){if(!e)return null;if("dialect"in e)return Z(e.dialect);if("createDriver"in e){if(e instanceof G)return"sqlite";if(e instanceof J)return"mysql";if(e instanceof z)return"postgres";if(e instanceof le)return"mssql"}return"aggregate"in e?"sqlite":"getConnection"in e?"mysql":"connect"in e?"postgres":null}n(Z,"getDatabaseType");var S=n(async e=>{let s=e.database;if(!s)return{kysely:null,databaseType:null};if("db"in s)return{kysely:s.db,databaseType:s.type};if("dialect"in s)return{kysely:new W({dialect:s.dialect}),databaseType:s.type};let f,l=Z(s);return"createDriver"in s&&(f=s),"aggregate"in s&&(f=new G({database:s})),"getConnection"in s&&(f=new J(s)),"connect"in s&&(f=new z({pool:s})),{kysely:f?new W({dialect:f}):null,databaseType:l}},"createKyselyAdapter");function q(e,s,f){return f==="update"?e:e==null&&s.defaultValue?typeof s.defaultValue=="function"?s.defaultValue():s.defaultValue:e}n(q,"withApplyDefault");var ce=n((e,s,f)=>{let l=k(s);function p(t,r){if(r==="id")return r;let a=l[t].fields[r];return a||console.log("Field not found",t,r),a.fieldName||r}n(p,"getField");function h(t,r,a){let{type:d="sqlite"}=f||{},o=l[r].fields[a];return o.type==="boolean"&&d==="sqlite"&&t!==null&&t!==void 0?t?1:0:o.type==="date"&&t&&t instanceof Date&&d==="sqlite"?t.toISOString():t}n(h,"transformValueToDB");function u(t,r,a){let{type:d="sqlite"}=f||{},o=l[r].fields[a];return o.type==="boolean"&&d==="sqlite"&&t!==null?t===1:o.type==="date"&&t?new Date(t):t}n(u,"transformValueFromDB");function g(t){return l[t].modelName}n(g,"getModelName");let m=s?.advanced?.generateId===!1;return{transformInput(t,r,a){let d=m||a==="update"?{}:{id:s.advanced?.generateId?s.advanced.generateId({model:r}):t.id||R()},o=l[r].fields;for(let i in o){let c=t[i];d[o[i].fieldName||i]=q(h(c,r,i),o[i],a)}return d},transformOutput(t,r,a=[]){if(!t)return null;let d=t.id?a.length===0||a.includes("id")?{id:t.id}:{}:{},o=l[r].fields;for(let i in o){if(a.length&&!a.includes(i))continue;let c=o[i];c&&(d[i]=u(t[c.fieldName||i],r,i))}return d},convertWhereClause(t,r){if(!r)return{and:null,or:null};let a={and:[],or:[]};return r.forEach(d=>{let{field:o,value:i,operator:c="=",connector:A="AND"}=d,y=p(t,o),b=n(x=>c.toLowerCase()==="in"?x(y,"in",Array.isArray(i)?i:[i]):c==="contains"?x(y,"like",`%${i}%`):c==="starts_with"?x(y,"like",`${i}%`):c==="ends_with"?x(y,"like",`%${i}`):c==="eq"?x(y,"=",i):c==="ne"?x(y,"<>",i):c==="gt"?x(y,">",i):c==="gte"?x(y,">=",i):c==="lt"?x(y,"<",i):c==="lte"?x(y,"<=",i):x(y,c,i),"expr");A==="OR"?a.or.push(b):a.and.push(b)}),{and:a.and.length?a.and:null,or:a.or.length?a.or:null}},async withReturning(t,r,a,d){let o;if(f?.type!=="mysql")o=await r.returningAll().executeTakeFirst();else{await r.execute();let i=t.id?"id":d[0].field?d[0].field:"id",c=t[i]||d[0].value;o=await e.selectFrom(g(a)).selectAll().where(p(a,i),"=",c).executeTakeFirst()}return o},getModelName:g,getField:p}},"createTransform"),Q=n((e,s)=>f=>{let{transformInput:l,withReturning:p,transformOutput:h,convertWhereClause:u,getModelName:g,getField:m}=ce(e,f,s);return{id:"kysely",async create(t){let{model:r,data:a,select:d}=t,o=l(a,r,"create"),i=e.insertInto(g(r)).values(o);return h(await p(o,i,r,[]),r,d)},async findOne(t){let{model:r,where:a,select:d}=t,{and:o,or:i}=u(r,a),c=e.selectFrom(g(r)).selectAll();o&&(c=c.where(y=>y.and(o.map(b=>b(y))))),i&&(c=c.where(y=>y.or(i.map(b=>b(y)))));let A=await c.executeTakeFirst();return A?h(A,r,d):null},async findMany(t){let{model:r,where:a,limit:d,offset:o,sortBy:i}=t,{and:c,or:A}=u(r,a),y=e.selectFrom(g(r));c&&(y=y.where(x=>x.and(c.map(T=>T(x))))),A&&(y=y.where(x=>x.or(A.map(T=>T(x))))),y=y.limit(d||100),o&&(y=y.offset(o)),i&&(y=y.orderBy(m(r,i.field),i.direction));let b=await y.selectAll().execute();return b?b.map(x=>h(x,r)):[]},async update(t){let{model:r,where:a,update:d}=t,{and:o,or:i}=u(r,a),c=l(d,r,"update"),A=e.updateTable(g(r)).set(c);return o&&(A=A.where(b=>b.and(o.map(x=>x(b))))),i&&(A=A.where(b=>b.or(i.map(x=>x(b))))),await h(await p(c,A,r,a),r)},async updateMany(t){let{model:r,where:a,update:d}=t,{and:o,or:i}=u(r,a),c=l(d,r,"update"),A=e.updateTable(g(r)).set(c);return o&&(A=A.where(b=>b.and(o.map(x=>x(b))))),i&&(A=A.where(b=>b.or(i.map(x=>x(b))))),(await A.execute()).length},async delete(t){let{model:r,where:a}=t,{and:d,or:o}=u(r,a),i=e.deleteFrom(g(r));d&&(i=i.where(c=>c.and(d.map(A=>A(c))))),o&&(i=i.where(c=>c.or(o.map(A=>A(c))))),await i.execute()},async deleteMany(t){let{model:r,where:a}=t,{and:d,or:o}=u(r,a),i=e.deleteFrom(g(r));return d&&(i=i.where(c=>c.and(d.map(A=>A(c))))),o&&(i=i.where(c=>c.or(o.map(A=>A(c))))),(await i.execute()).length},options:s}},"kyselyAdapter");var fe=n(e=>{let s=k(e);function f(l,p){return p==="id"?p:s[l].fields[p].fieldName||p}return n(f,"getField"),{transformInput(l,p,h){let u=h==="update"?{}:{id:e.advanced?.generateId?e.advanced.generateId({model:p}):l.id||R()},g=s[p].fields;for(let m in g){let t=l[m];t===void 0&&!g[m].defaultValue||(u[g[m].fieldName||m]=q(t,g[m],h))}return u},transformOutput(l,p,h=[]){if(!l)return null;let u=l.id||l._id?h.length===0||h.includes("id")?{id:l.id}:{}:{},g=s[p].fields;for(let m in g){if(h.length&&!h.includes(m))continue;let t=g[m];t&&(u[m]=l[t.fieldName||m])}return u},convertWhereClause(l,p,h){return p.filter(u=>l.every(g=>{let{field:m,value:t,operator:r}=g,a=f(h,m);if(r==="in"){if(!Array.isArray(t))throw new Error("Value must be an array");return t.includes(u[a])}else return r==="contains"?u[a].includes(t):r==="starts_with"?u[a].startsWith(t):r==="ends_with"?u[a].endsWith(t):u[a]===t}))},getField:f}},"createTransform"),X=n(e=>s=>{let{transformInput:f,transformOutput:l,convertWhereClause:p,getField:h}=fe(s);return{id:"memory",create:n(async({model:u,data:g})=>{let m=f(g,u,"create");return e[u].push(m),l(m,u)},"create"),findOne:n(async({model:u,where:g,select:m})=>{let t=e[u],a=p(g,t,u)[0]||null;return l(a,u,m)},"findOne"),findMany:n(async({model:u,where:g,sortBy:m,limit:t,offset:r})=>{let a=e[u];return g&&(a=p(g,a,u)),m&&(a=a.sort((d,o)=>{let i=h(u,m.field);return m.direction==="asc"?d[i]>o[i]?1:-1:d[i]<o[i]?1:-1})),r!==void 0&&(a=a.slice(r)),t!==void 0&&(a=a.slice(0,t)),a.map(d=>l(d,u))},"findMany"),update:n(async({model:u,where:g,update:m})=>{let t=e[u],r=p(g,t,u);return r.forEach(a=>{Object.assign(a,f(m,u,"update"))}),l(r[0],u)},"update"),delete:n(async({model:u,where:g})=>{let m=e[u],t=p(g,m,u);e[u]=m.filter(r=>!t.includes(r))},"delete"),deleteMany:n(async({model:u,where:g})=>{let m=e[u],t=p(g,m,u),r=0;return e[u]=m.filter(a=>t.includes(a)?(r++,!1):!t.includes(a)),r},"deleteMany"),updateMany(u){let{model:g,where:m,update:t}=u,r=e[g],a=p(m,r,g);return a.forEach(d=>{Object.assign(d,t)}),a[0]||null}}},"memoryAdapter");async function Cr(e){if(!e.database){let l=k(e),p=Object.keys(l).reduce((h,u)=>(h[u]=[],h),{});return H.warn("No database configuration provided. Using memory adapter in development"),X(p)(e)}if(typeof e.database=="function")return e.database(e);let{kysely:s,databaseType:f}=await S(e);if(!s)throw new D("Failed to initialize database adapter");return Q(s,{type:f||"sqlite"})(e)}n(Cr,"getAdapter");function jr(e,s){let f=s.id?{id:s.id}:{};for(let l in e){let p=e[l],h=s[l];h!==void 0&&(f[p.fieldName||l]=h)}return f}n(jr,"convertToDB");function $r(e,s){if(!s)return null;let f={id:s.id};for(let[l,p]of Object.entries(e))f[l]=s[p.fieldName||l];return f}n($r,"convertFromDB");function Y(e){let s=k(e),f={};for(let l in s){let p=s[l],h=p.fields,u={};if(Object.entries(h).forEach(([g,m])=>{if(u[m.fieldName||g]=m,m.references){let t=s[m.references.model];t&&(u[m.fieldName||g].references={model:t.modelName,field:m.references.field})}}),f[p.modelName]){f[p.modelName].fields={...f[p.modelName].fields,...u};continue}f[p.modelName]={fields:u,order:p.order||1/0}}return f}n(Y,"getSchema");var pe={string:["character varying","text"],number:["int4","integer","bigint","smallint","numeric","real","double precision"],boolean:["bool","boolean"],date:["timestamp","date"]},me={string:["varchar","text"],number:["integer","int","bigint","smallint","decimal","float","double"],boolean:["boolean","tinyint"],date:["timestamp","datetime","date"]},ye={string:["TEXT"],number:["INTEGER","REAL"],boolean:["INTEGER","BOOLEAN"],date:["DATE","INTEGER"]},ge={string:["nvarchar","varchar"],number:["int","bigint","smallint","decimal","float","double"],boolean:["bit","boolean"],date:["datetime","date"]},Ae={postgres:pe,mysql:me,sqlite:ye,mssql:ge};function he(e,s,f){if(s==="string[]"||s==="number[]")return e.toLowerCase().includes("json");let l=Ae[f];return(Array.isArray(s)?l.string.map(u=>u.toLowerCase()):l[s].map(u=>u.toLowerCase())).includes(e.toLowerCase())}n(he,"matchType");async function Xr(e){let s=Y(e),f=V(e.logger),{kysely:l,databaseType:p}=await S(e);p||(f.warn("Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this."),p="sqlite"),l||(f.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter."),process.exit(1));let h=await l.introspection.getTables(),u=[],g=[];for(let[d,o]of Object.entries(s)){let i=h.find(A=>A.name===d);if(!i){let A=u.findIndex(x=>x.table===d),y={table:d,fields:o.fields,order:o.order||1/0},b=u.findIndex(x=>(x.order||1/0)>y.order);b===-1?A===-1?u.push(y):u[A].fields={...u[A].fields,...o.fields}:u.splice(b,0,y);continue}let c={};for(let[A,y]of Object.entries(o.fields)){let b=i.columns.find(x=>x.name===A);if(!b){c[A]=y;continue}he(b.dataType,y.type,p)||f.warn(`Field ${A} in table ${d} has a different type in the database. Expected ${y.type} but got ${b.dataType}.`)}Object.keys(c).length>0&&g.push({table:d,fields:c,order:o.order||1/0})}let m=[];function t(d){let o=d.type,i={string:{sqlite:"text",postgres:"text",mysql:d.unique?"varchar(255)":d.references?"varchar(36)":"text",mssql:"text"},boolean:{sqlite:"integer",postgres:"boolean",mysql:"boolean",mssql:"boolean"},number:{sqlite:"integer",postgres:"integer",mysql:"integer",mssql:"integer"},date:{sqlite:"date",postgres:"timestamp",mysql:"datetime",mssql:"datetime"}};return p==="sqlite"&&(o==="string[]"||o==="number[]")?"text":o==="string[]"||o==="number[]"?"jsonb":Array.isArray(o)?"text":i[o][p||"sqlite"]}if(n(t,"getType"),g.length)for(let d of g)for(let[o,i]of Object.entries(d.fields)){let c=t(i),A=l.schema.alterTable(d.table).addColumn(o,c,y=>(y=i.required!==!1?y.notNull():y,i.references&&(y=y.references(`${i.references.model}.${i.references.field}`)),i.unique&&(y=y.unique()),y));m.push(A)}if(u.length)for(let d of u){let o=l.schema.createTable(d.table).addColumn("id",p==="mysql"?"varchar(36)":"text",i=>i.primaryKey().notNull());for(let[i,c]of Object.entries(d.fields)){let A=t(c);o=o.addColumn(i,A,y=>(y=c.required!==!1?y.notNull():y,c.references&&(y=y.references(`${c.references.model}.${c.references.field}`)),c.unique&&(y=y.unique()),y))}m.push(o)}async function r(){for(let d of m)await d.execute()}n(r,"runMigrations");async function a(){return m.map(o=>o.compile().sql).join(`;

`)}return n(a,"compileMigrations"),{toBeCreated:u,toBeAdded:g,runMigrations:r,compileMigrations:a}}n(Xr,"getMigrations");export{$r as convertFromDB,jr as convertToDB,ir as createFieldAttribute,tr as createInternalAdapter,Cr as getAdapter,k as getAuthTables,Xr as getMigrations,Y as getSchema,C as getWithHooks,he as matchType,lr as toZodSchema};
